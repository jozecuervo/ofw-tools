/**
 * @fileoverview iMessage API
 * @description This file contains an iMessage parer that parses iMessage data from a txt file.
 * the data is then used to create a JSON file that contains the data in a more readable format.
 * Input files are expected to be generated by [imessage-exporter](https://github.com/ReagentX/imessage-exporter)
 */
import fs from 'fs';
import Sentiment from 'sentiment';
import natural from 'natural';
import { polarity } from 'polarity';

const sentiment = new Sentiment();

// let polarity;

// async function loadPolarity() {
//     const module = await import('polarity');
//     polarity = module.default;
// }

// // Call this function before using `polarity`
// loadPolarity();
const analyzer = new natural.SentimentAnalyzer('English', natural.PorterStemmer, 'afinn');

/**
 * 
 * Parses an iMessage-exported text file and extracts message data.
 * @param {string} filePath - The path to the text file.
 * @return {Promise<Array>} - A promise that resolves to an array of message objects.
 */
function parseIMessageFile(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf8', (err, data) => {
            if (err) {
                reject(err);
                return;
            }

            const messages = [];
            const lines = data.split('\n');
            let currentMessage = {};

            lines.forEach((line, index) => {
                if (line.match(/^\s*$/)) {
                    return; // Skip empty lines
                }

                if (line.match(/\d{1,2}:\d{2}:\d{2} [AP]M/)) {
                    // Save previous message and start a new one
                    if (currentMessage.sender) {
                        messages.push(currentMessage);
                    }
                    currentMessage = {
                        timestamp: line.split('(')[0].trim(),
                        readInfo: line.split('(')[1]?.split(')')[0]?.trim() || null
                    };
                } else if (!currentMessage.sender) {
                    currentMessage.sender = line.trim();
                    currentMessage.content = '';
                } else {
                    currentMessage.content += line.trim() + '\n';
                }

                // When completing a message, perform sentiment analysis
                if (currentMessage.sender) {
                    const sentimentResult = sentiment.analyze(currentMessage.content);  
                    const naturalResult = analyzer.getSentiment(currentMessage.content.split(/\s+/));
                    const contentArray = currentMessage.content.split(/\s+/);

                    const polarityResult = polarity(contentArray);
                    console.log(`message '${currentMessage.content}'`);
                    console.log(`Sentiment score: ${sentimentResult.score}`);
                    console.log(`Natural score: ${naturalResult}`);
                    console.log(`Polarity score: `);
                    console.log(polarityResult);


                    // Combining the scores from both libraries
                    currentMessage.sentiment = {
                        sentimentScore: sentimentResult.score,
                        naturalScore: naturalResult,
                        polarityScore: polarityResult,
                    };
                    messages.push(currentMessage);
                }
            });

            resolve(messages);
        });
    });
}

// Example usage
const filePath = '/Users/jose/projects/ofw-tools/source_files/imessage.txt';
parseIMessageFile(filePath)
    .then(messages => {
        // console.log(messages); // Process or display the messages
    })
    .catch(error => {
        console.error('Error parsing iMessage file:', error);
    });
